#!/usr/bin/env python3
"""iCalendar Validation Script for Hugo iCalendar Templates.

This script validates the generated .ics files to ensure they:
1. Are valid iCalendar format
2. Contain expected properties
3. Have correct recurrence rules
4. Match the source markdown content
"""

import sys
from pathlib import Path
from typing import Any

import structlog
import yaml
from icalendar import Calendar, Component

# Configure structlog
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(),
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

log = structlog.get_logger()

# Constants
MIN_PATH_PARTS = 2
CALENDAR_FILENAME = "calendar.ics"


class ICalValidator:
    """Validator for iCalendar files generated by Hugo templates."""

    def __init__(self) -> None:
        """Initialize the validator with empty error and warning lists."""
        self.errors: list[str] = []
        self.warnings: list[str] = []
        self.validated_files: int = 0

    def log_error(self, message: str, **kwargs: Any) -> None:
        """Log an error message."""
        self.errors.append(message)
        log.error(message, **kwargs)

    def log_warning(self, message: str, **kwargs: Any) -> None:
        """Log a warning message."""
        self.warnings.append(message)
        log.warning(message, **kwargs)

    def log_info(self, message: str, **kwargs: Any) -> None:
        """Log an info message."""
        log.info(message, **kwargs)

    def parse_markdown_frontmatter(self, md_file: str) -> dict[str, Any]:
        """Parse the YAML frontmatter from a markdown file."""
        try:
            content = Path(md_file).read_text(encoding="utf-8")

            # Extract frontmatter between --- markers
            if content.startswith("---\n"):
                end_marker = content.find("\n---\n", 4)
                if end_marker != -1:
                    frontmatter = content[4:end_marker]
                    return yaml.safe_load(frontmatter) or {}
            else:
                return {}
        except (OSError, yaml.YAMLError) as e:
            self.log_error(
                "Failed to parse frontmatter from file",
                md_file=md_file,
                error=str(e),
            )
        return {}

    def validate_ical_structure(self, cal: Calendar, ics_file: str) -> Component | None:
        """Validate basic iCalendar structure."""
        self.log_info("Validating structure", ics_file=ics_file)

        # Check for required calendar properties
        if not cal.get("VERSION"):
            self.log_error("Missing VERSION property", ics_file=ics_file)

        if not cal.get("PRODID"):
            self.log_error("Missing PRODID property", ics_file=ics_file)

        # Check for events
        events = [component for component in cal.walk() if component.name == "VEVENT"]
        if not events:
            self.log_error("No VEVENT components found", ics_file=ics_file)
            return None

        return events[0]  # Return first event for further validation

    def validate_event_properties(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate event properties against frontmatter."""
        self.log_info("Validating event properties", ics_file=ics_file)

        # Check SUMMARY (title)
        if "title" in frontmatter:
            summary = event.get("SUMMARY")
            if summary:
                if str(summary) != frontmatter["title"]:
                    self.log_error(
                        "SUMMARY doesn't match title",
                        ics_file=ics_file,
                        summary=str(summary),
                        expected_title=frontmatter["title"],
                    )
            else:
                self.log_error("Missing SUMMARY property", ics_file=ics_file)

        # Check DTSTART
        if "startDate" in frontmatter:
            dtstart = event.get("DTSTART")
            if not dtstart:
                self.log_error("Missing DTSTART property", ics_file=ics_file)

        # Check DTEND
        if "endDate" in frontmatter:
            dtend = event.get("DTEND")
            if not dtend:
                self.log_error("Missing DTEND property", ics_file=ics_file)

        # Check UID
        uid = event.get("UID")
        if not uid:
            self.log_error("Missing UID property", ics_file=ics_file)

        # Check DTSTAMP
        dtstamp = event.get("DTSTAMP")
        if not dtstamp:
            self.log_error("Missing DTSTAMP property", ics_file=ics_file)

    def _validate_freq(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate FREQ parameter."""
        if "freq" in expected_rule:
            actual_freq = rrule.get("FREQ")
            expected_freq = [expected_rule["freq"]]
            if actual_freq != expected_freq:
                self.log_error(
                    "FREQ mismatch",
                    ics_file=ics_file,
                    expected=expected_rule["freq"],
                    actual=actual_freq,
                )

    def _validate_bymonth(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYMONTH parameter."""
        if "byMonth" in expected_rule:
            expected_month = [expected_rule["byMonth"]]
            actual_month = rrule.get("BYMONTH")
            if actual_month != expected_month:
                self.log_error(
                    "BYMONTH mismatch",
                    ics_file=ics_file,
                    expected=expected_month,
                    actual=actual_month,
                )

    def _validate_byday(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYDAY parameter."""
        if "byDay" in expected_rule:
            expected_day = [expected_rule["byDay"]]
            actual_day = rrule.get("BYDAY")
            if actual_day != expected_day:
                self.log_error(
                    "BYDAY mismatch",
                    ics_file=ics_file,
                    expected=expected_day,
                    actual=actual_day,
                )

    def _validate_bysetpos(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYSETPOS parameter."""
        if "bySetPos" in expected_rule:
            expected_setpos = expected_rule["bySetPos"]
            if isinstance(expected_setpos, list):
                expected_setpos_list = expected_setpos
            else:
                expected_setpos_list = [expected_setpos]
            actual_setpos = rrule.get("BYSETPOS")
            if actual_setpos != expected_setpos_list:
                self.log_error(
                    "BYSETPOS mismatch",
                    ics_file=ics_file,
                    expected=expected_setpos_list,
                    actual=actual_setpos,
                )

    def _validate_interval(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate INTERVAL parameter."""
        if "interval" in expected_rule:
            expected_interval = [expected_rule["interval"]]
            actual_interval = rrule.get("INTERVAL")
            if actual_interval != expected_interval:
                self.log_error(
                    "INTERVAL mismatch",
                    ics_file=ics_file,
                    expected=expected_interval,
                    actual=actual_interval,
                )

    def validate_recurrence_rule(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate recurrence rule against frontmatter."""
        if "recurrenceRule" not in frontmatter:
            return  # No recurrence rule expected

        self.log_info("Validating recurrence rule", ics_file=ics_file)

        rrule = event.get("RRULE")
        if not rrule:
            self.log_error("Expected RRULE but none found", ics_file=ics_file)
            return

        expected_rule = frontmatter["recurrenceRule"]

        # Validate individual components
        self._validate_freq(rrule, expected_rule, ics_file)
        self._validate_bymonth(rrule, expected_rule, ics_file)
        self._validate_byday(rrule, expected_rule, ics_file)
        self._validate_bysetpos(rrule, expected_rule, ics_file)
        self._validate_interval(rrule, expected_rule, ics_file)

    def validate_ics_file(self, ics_file: str, md_file: str | None = None) -> bool:
        """Validate a single .ics file."""
        self.log_info("Validating file", ics_file=ics_file)

        try:
            ics_data = Path(ics_file).read_text(encoding="utf-8")
            cal = Calendar.from_ical(ics_data)
        except (OSError, ValueError) as e:
            self.log_error("Failed to parse file", ics_file=ics_file, error=str(e))
            return False

        # Validate basic structure
        event = self.validate_ical_structure(cal, ics_file)
        if event is None:
            return False

        # If we have a corresponding markdown file, validate against it
        if md_file and Path(md_file).exists():
            frontmatter = self.parse_markdown_frontmatter(md_file)
            if frontmatter:
                self.validate_event_properties(event, frontmatter, ics_file)
                self.validate_recurrence_rule(event, frontmatter, ics_file)

        self.validated_files += 1
        return True

    def find_corresponding_markdown(self, ics_file: str) -> str | None:
        """Find the corresponding markdown file for an .ics file."""
        # Extract event name from path
        # e.g., demo/public/events/event_3_yearly_april/calendar.ics
        # -> event_3_yearly_april
        path_parts = Path(ics_file).parts
        if len(path_parts) >= MIN_PATH_PARTS and path_parts[-1] == CALENDAR_FILENAME:
            event_name = path_parts[-2]
            md_file = f"demo/content/events/{event_name}.md"
            if Path(md_file).exists():
                return md_file
        return None

    def validate_all_files(self) -> bool:
        """Validate all .ics files in the demo/public/events directory."""
        ics_files = list(Path("demo/public/events").rglob("*.ics"))

        if not ics_files:
            self.log_error("No .ics files found in demo/public/events/")
            return False

        self.log_info("Found files to validate", count=len(ics_files))

        success = True
        for ics_file in sorted(ics_files):
            md_file = self.find_corresponding_markdown(str(ics_file))
            if not self.validate_ics_file(str(ics_file), md_file):
                success = False

        return success

    def generate_report(self) -> bool:
        """Generate a validation report."""
        report = []
        report.append("iCalendar Validation Report")
        report.append("=" * 30)
        report.append(f"Files validated: {self.validated_files}")
        report.append(f"Errors: {len(self.errors)}")
        report.append(f"Warnings: {len(self.warnings)}")
        report.append("")

        if self.errors:
            report.append("ERRORS:")
            report.extend(f"  - {error}" for error in self.errors)
            report.append("")

        if self.warnings:
            report.append("WARNINGS:")
            report.extend(f"  - {warning}" for warning in self.warnings)
            report.append("")

        if not self.errors and not self.warnings:
            report.append("✅ All validations passed!")

        report_content = "\n".join(report)

        # Write report to file
        Path("validation-report.txt").write_text(report_content, encoding="utf-8")

        print(f"\n{report_content}")  # noqa: T201

        return len(self.errors) == 0


def main() -> None:
    """Run the main validation process."""
    print("Starting iCalendar validation...")  # noqa: T201

    validator = ICalValidator()
    validator.validate_all_files()
    overall_success = validator.generate_report()

    if overall_success:
        print("\n✅ Validation completed successfully!")  # noqa: T201
        sys.exit(0)
    else:
        print(
            f"\n❌ Validation failed with {len(validator.errors)} errors",
        )
        sys.exit(1)


if __name__ == "__main__":
    main()
