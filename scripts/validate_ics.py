#!/usr/bin/env python3
"""iCalendar Validation Script for Hugo iCalendar Templates.

This script validates the generated .ics files to ensure they:
1. Are valid iCalendar format
2. Contain expected properties
3. Have correct recurrence rules
4. Match the source markdown content
"""

# ruff: noqa: T201, ANN401, E501

import sys
from pathlib import Path
from typing import Any

import structlog
import yaml
from dateutil.rrule import rrulestr
from icalendar import Calendar, Component

# Configure structlog
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(),
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

log = structlog.get_logger()

# Constants
MIN_PATH_PARTS = 2
CALENDAR_FILENAME = "calendar.ics"


class ICalValidator:
    """Validator for iCalendar files generated by Hugo templates."""

    def __init__(self) -> None:
        """Initialize the validator with empty error and warning lists."""
        self.errors: list[str] = []
        self.warnings: list[str] = []
        self.validated_files: int = 0

    def log_error(self, message: str, **kwargs: Any) -> None:
        """Log an error message."""
        # Include file name in the error message if available
        ics_file = kwargs.get("ics_file", "")
        formatted_message = f"{message} (file: {ics_file})" if ics_file else message
        self.errors.append(formatted_message)
        log.error(message, **kwargs)

    def log_warning(self, message: str, **kwargs: Any) -> None:
        """Log a warning message."""
        # Include file name in the warning message if available
        ics_file = kwargs.get("ics_file", "")
        formatted_message = f"{message} (file: {ics_file})" if ics_file else message
        self.warnings.append(formatted_message)
        log.warning(message, **kwargs)

    def log_info(self, message: str, **kwargs: Any) -> None:
        """Log an info message."""
        log.info(message, **kwargs)

    def parse_markdown_frontmatter(self, md_file: str) -> dict[str, Any]:
        """Parse the YAML frontmatter from a markdown file."""
        try:
            content = Path(md_file).read_text(encoding="utf-8")

            # Extract frontmatter between --- markers
            if content.startswith("---\n"):
                end_marker = content.find("\n---\n", 4)
                if end_marker != -1:
                    frontmatter = content[4:end_marker]
                    return yaml.safe_load(frontmatter) or {}
            else:
                return {}
        except (OSError, yaml.YAMLError) as e:
            self.log_error(
                "Failed to parse frontmatter from file",
                md_file=md_file,
                error=str(e),
            )
        return {}

    def validate_ical_structure(
        self,
        cal: Component,
        ics_file: str,
    ) -> Component | None:
        """Validate basic iCalendar structure."""
        self.log_info("Validating structure", ics_file=ics_file)

        # Check for required calendar properties
        if not cal.get("VERSION"):
            self.log_error("Missing VERSION property", ics_file=ics_file)

        if not cal.get("PRODID"):
            self.log_error("Missing PRODID property", ics_file=ics_file)

        # Check for events
        events = [component for component in cal.walk() if component.name == "VEVENT"]
        if not events:
            self.log_error("No VEVENT components found", ics_file=ics_file)
            return None

        return events[0]  # Return first event for further validation

    def validate_event_properties(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate event properties against frontmatter."""
        self.log_info("Validating event properties", ics_file=ics_file)

        # Check SUMMARY (title)
        if "title" in frontmatter:
            summary = event.get("SUMMARY")
            if summary:
                if str(summary) != frontmatter["title"]:
                    self.log_error(
                        "SUMMARY doesn't match title",
                        ics_file=ics_file,
                        summary=str(summary),
                        expected_title=frontmatter["title"],
                    )
            else:
                self.log_error("Missing SUMMARY property", ics_file=ics_file)

        # Check DTSTART
        if "startDate" in frontmatter:
            dtstart = event.get("DTSTART")
            if not dtstart:
                self.log_error("Missing DTSTART property", ics_file=ics_file)

        # Check DTEND
        if "endDate" in frontmatter:
            dtend = event.get("DTEND")
            if not dtend:
                self.log_error("Missing DTEND property", ics_file=ics_file)

        # Check UID
        uid = event.get("UID")
        if not uid:
            self.log_error("Missing UID property", ics_file=ics_file)

        # Check DTSTAMP
        dtstamp = event.get("DTSTAMP")
        if not dtstamp:
            self.log_error("Missing DTSTAMP property", ics_file=ics_file)

    def _validate_freq(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate FREQ parameter."""
        if "freq" in expected_rule:
            actual_freq = rrule.get("FREQ")
            expected_freq = [expected_rule["freq"]]
            if actual_freq != expected_freq:
                self.log_error(
                    "FREQ mismatch",
                    ics_file=ics_file,
                    expected=expected_rule["freq"],
                    actual=actual_freq,
                )

    def _validate_bymonth(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYMONTH parameter."""
        if "byMonth" in expected_rule:
            expected_month = [expected_rule["byMonth"]]
            actual_month = rrule.get("BYMONTH")
            if actual_month != expected_month:
                self.log_error(
                    "BYMONTH mismatch",
                    ics_file=ics_file,
                    expected=expected_month,
                    actual=actual_month,
                )

    def _validate_byday(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYDAY parameter."""
        if "byDay" in expected_rule:
            expected_day = expected_rule["byDay"]
            # Normalize to list for comparison
            if not isinstance(expected_day, list):
                expected_day = [expected_day]

            actual_day = rrule.get("BYDAY")
            if actual_day != expected_day:
                self.log_error(
                    "BYDAY mismatch",
                    ics_file=ics_file,
                    expected=expected_day,
                    actual=actual_day,
                )

    def _validate_bysetpos(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYSETPOS parameter."""
        if "bySetPos" in expected_rule:
            expected_setpos = expected_rule["bySetPos"]
            if isinstance(expected_setpos, list):
                expected_setpos_list = expected_setpos
            else:
                expected_setpos_list = [expected_setpos]
            actual_setpos = rrule.get("BYSETPOS")
            if actual_setpos != expected_setpos_list:
                self.log_error(
                    "BYSETPOS mismatch",
                    ics_file=ics_file,
                    expected=expected_setpos_list,
                    actual=actual_setpos,
                )

    def _validate_interval(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate INTERVAL parameter."""
        if "interval" in expected_rule:
            expected_interval = [expected_rule["interval"]]
            actual_interval = rrule.get("INTERVAL")
            if actual_interval != expected_interval:
                self.log_error(
                    "INTERVAL mismatch",
                    ics_file=ics_file,
                    expected=expected_interval,
                    actual=actual_interval,
                )

    def show_recurrence_entries(self, event: Component, ics_file: str) -> None:
        """Show the first 4 entries from recurrence rules."""
        rrule = event.get("RRULE")
        if not rrule:
            return

        dtstart = event.get("DTSTART")
        if not dtstart:
            return

        try:
            # Convert rrule to string format for dateutil
            rrule_str = str(rrule).replace("RRULE:", "")
            start_dt = dtstart.dt

            # Handle timezone-aware datetime
            if hasattr(start_dt, "replace") and start_dt.tzinfo is None:
                start_dt = start_dt.replace(tzinfo=None)

            # Generate first 4 occurrences
            rule = rrulestr(rrule_str, dtstart=start_dt)
            occurrences = list(rule[:4])

            print(f"\n📅 First 4 recurrence entries for {ics_file}:")
            for i, occurrence in enumerate(occurrences, 1):
                print(f"  {i}. {occurrence.strftime('%Y-%m-%d %H:%M:%S')}")

        except Exception as e:  # noqa: BLE001
            self.log_warning(
                f"Could not generate recurrence entries: {e}",
                ics_file=ics_file,
            )

    def validate_valarm_components(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate VALARM components against frontmatter."""
        if "alarms" not in frontmatter:
            return  # No alarms expected

        self.log_info("Validating VALARM components", ics_file=ics_file)

        # Find VALARM components
        valarms = [
            component for component in event.walk() if component.name == "VALARM"
        ]
        expected_alarms = frontmatter["alarms"]

        if len(valarms) != len(expected_alarms):
            self.log_error(
                "VALARM count mismatch",
                ics_file=ics_file,
                expected=len(expected_alarms),
                actual=len(valarms),
            )
            return

        # Validate each VALARM component
        for i, (valarm, expected_alarm) in enumerate(
            zip(valarms, expected_alarms, strict=True),
        ):
            self._validate_single_valarm(valarm, expected_alarm, ics_file, i)

    def _validate_single_valarm(
        self,
        valarm: Component,
        expected_alarm: dict[str, Any],
        ics_file: str,
        alarm_index: int,
    ) -> None:
        """Validate a single VALARM component."""
        # Check ACTION
        if "action" in expected_alarm:
            actual_action = valarm.get("ACTION")
            expected_action = expected_alarm["action"]
            if str(actual_action) != expected_action:
                self.log_error(
                    f"VALARM[{alarm_index}] ACTION mismatch",
                    ics_file=ics_file,
                    expected=expected_action,
                    actual=str(actual_action),
                )

        # Check TRIGGER
        if "trigger" in expected_alarm:
            actual_trigger = valarm.get("TRIGGER")
            expected_trigger = expected_alarm["trigger"]
            if "duration" in expected_trigger:
                # Get the raw TRIGGER value from the iCalendar component
                # The iCalendar library parses TRIGGER into vDDDTypes objects
                # We need to get the original string value for comparison
                expected_trigger_str = expected_trigger["duration"].strip()

                # Try to get the raw value from the component
                actual_trigger_str = None
                if hasattr(actual_trigger, "to_ical"):
                    # Get the raw iCalendar representation
                    actual_trigger_str = (
                        actual_trigger.to_ical().decode("utf-8").strip()
                    )
                else:
                    # Fallback to string representation
                    actual_trigger_str = str(actual_trigger).strip()

                if actual_trigger_str != expected_trigger_str:
                    self.log_error(
                        f"VALARM[{alarm_index}] TRIGGER duration mismatch",
                        ics_file=ics_file,
                        expected=expected_trigger_str,
                        actual=actual_trigger_str,
                    )

        # Check DESCRIPTION for DISPLAY and EMAIL alarms
        if (
            expected_alarm.get("action") in ["DISPLAY", "EMAIL"]
            and "description" in expected_alarm
        ):
            actual_description = valarm.get("DESCRIPTION")
            expected_description = expected_alarm["description"]["text"]
            if str(actual_description) != expected_description:
                self.log_error(
                    f"VALARM[{alarm_index}] DESCRIPTION mismatch",
                    ics_file=ics_file,
                    expected=expected_description,
                    actual=str(actual_description),
                )

        # Check SUMMARY for EMAIL alarms
        if expected_alarm.get("action") == "EMAIL" and "summary" in expected_alarm:
            actual_summary = valarm.get("SUMMARY")
            expected_summary = expected_alarm["summary"]["text"]
            if str(actual_summary) != expected_summary:
                self.log_error(
                    f"VALARM[{alarm_index}] SUMMARY mismatch",
                    ics_file=ics_file,
                    expected=expected_summary,
                    actual=str(actual_summary),
                )

    def validate_recurrence_rule(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate recurrence rule against frontmatter."""
        if "recurrenceRule" not in frontmatter:
            return  # No recurrence rule expected

        self.log_info("Validating recurrence rule", ics_file=ics_file)

        rrule = event.get("RRULE")
        if not rrule:
            self.log_error("Expected RRULE but none found", ics_file=ics_file)
            return

        # Show first 4 recurrence entries
        self.show_recurrence_entries(event, ics_file)

        expected_rule = frontmatter["recurrenceRule"]

        # Validate individual components
        self._validate_freq(rrule, expected_rule, ics_file)
        self._validate_bymonth(rrule, expected_rule, ics_file)
        self._validate_byday(rrule, expected_rule, ics_file)
        self._validate_bysetpos(rrule, expected_rule, ics_file)
        self._validate_interval(rrule, expected_rule, ics_file)

    def validate_ics_file(self, ics_file: str, md_file: str | None = None) -> bool:
        """Validate a single .ics file."""
        self.log_info("Validating file", ics_file=ics_file)

        try:
            ics_data = Path(ics_file).read_text(encoding="utf-8")
            cal = Calendar.from_ical(ics_data)
        except (OSError, ValueError) as e:
            self.log_error("Failed to parse file", ics_file=ics_file, error=str(e))
            return False

        # Validate basic structure
        event = self.validate_ical_structure(cal, ics_file)
        if event is None:
            return False

        # If we have a corresponding markdown file, validate against it
        if md_file and Path(md_file).exists():
            frontmatter = self.parse_markdown_frontmatter(md_file)
            if frontmatter:
                self.validate_event_properties(event, frontmatter, ics_file)
                self.validate_recurrence_rule(event, frontmatter, ics_file)
                self.validate_valarm_components(event, frontmatter, ics_file)

        self.validated_files += 1
        return True

    def find_corresponding_markdown(self, ics_file: str) -> str | None:
        """Find the corresponding markdown file for an .ics file."""
        # Extract event name from path
        # e.g., demo/public/events/event_3_yearly_april/calendar.ics
        # -> event_3_yearly_april
        path_parts = Path(ics_file).parts
        if len(path_parts) >= MIN_PATH_PARTS and path_parts[-1] == CALENDAR_FILENAME:
            event_name = path_parts[-2]
            md_file = f"demo/content/events/{event_name}.md"
            if Path(md_file).exists():
                return md_file
        return None

    def verify_recurrence_rule_consistency(self) -> bool:
        """Verify that markdown files with recurrenceRule have RRULE in their .ics files."""
        print("\n🔍 Verifying recurrence rule consistency...")

        # Find all markdown files with recurrenceRule
        md_files = list(Path("demo/content/events").glob("*.md"))
        md_files = [f for f in md_files if f.name != "_index.md"]

        success = True
        files_with_recurrence = 0

        for md_file in sorted(md_files):
            frontmatter = self.parse_markdown_frontmatter(str(md_file))
            if "recurrenceRule" in frontmatter:
                files_with_recurrence += 1
                event_name = md_file.stem
                ics_file = f"demo/public/events/{event_name}/calendar.ics"

                print(f"📋 Checking {event_name}:")
                print(f"   Markdown: {md_file}")
                print(f"   ICS file: {ics_file}")

                if not Path(ics_file).exists():
                    self.log_error(
                        f"ICS file not found for {event_name}",
                        md_file=str(md_file),
                    )
                    success = False
                    continue

                try:
                    ics_data = Path(ics_file).read_text(encoding="utf-8")
                    cal = Calendar.from_ical(ics_data)

                    # Find VEVENT component
                    events = [
                        component
                        for component in cal.walk()
                        if component.name == "VEVENT"
                    ]
                    if not events:
                        self.log_error(
                            f"No VEVENT found in {ics_file}",
                            md_file=str(md_file),
                        )
                        success = False
                        continue

                    event = events[0]
                    rrule = event.get("RRULE")

                    if rrule:
                        print(f"   ✅ RRULE found: {rrule}")
                    else:
                        self.log_error(
                            f"RRULE missing in {ics_file} but recurrenceRule present in {md_file}",
                        )
                        success = False

                except Exception as e:  # noqa: BLE001
                    self.log_error(
                        f"Error processing {ics_file}: {e}",
                        md_file=str(md_file),
                    )
                    success = False

        print(f"\n📊 Found {files_with_recurrence} markdown files with recurrenceRule")
        return success

    def validate_all_files(self) -> bool:
        """Validate all .ics files in the demo/public/events directory."""
        ics_files = list(Path("demo/public/events").rglob("*.ics"))

        if not ics_files:
            self.log_error("No .ics files found in demo/public/events/")
            return False

        self.log_info("Found files to validate", count=len(ics_files))

        success = True
        for ics_file in sorted(ics_files):
            md_file = self.find_corresponding_markdown(str(ics_file))
            if not self.validate_ics_file(str(ics_file), md_file):
                success = False

        # Also verify recurrence rule consistency
        if not self.verify_recurrence_rule_consistency():
            success = False

        return success

    def generate_report(self) -> bool:
        """Generate a validation report."""
        report = []
        report.append("iCalendar Validation Report")
        report.append("=" * 30)
        report.append(f"Files validated: {self.validated_files}")
        report.append(f"Errors: {len(self.errors)}")
        report.append(f"Warnings: {len(self.warnings)}")
        report.append("")

        if self.errors:
            report.append("ERRORS:")
            # Group errors by file
            error_by_file: dict[str, list[str]] = {}
            for error in self.errors:
                if "(file: " in error:
                    parts = error.split("(file: ")
                    message = parts[0].strip()
                    file_part = parts[1].rstrip(")")
                    if file_part not in error_by_file:
                        error_by_file[file_part] = []
                    error_by_file[file_part].append(message)
                else:
                    if "General" not in error_by_file:
                        error_by_file["General"] = []
                    error_by_file["General"].append(error)

            for file_name, file_errors in error_by_file.items():
                report.append(f"  📁 {file_name}:")
                for error in file_errors:
                    report.append(f"    - {error}")
                report.append("")

        if self.warnings:
            report.append("WARNINGS:")
            # Group warnings by file
            warning_by_file: dict[str, list[str]] = {}
            for warning in self.warnings:
                if "(file: " in warning:
                    parts = warning.split("(file: ")
                    message = parts[0].strip()
                    file_part = parts[1].rstrip(")")
                    if file_part not in warning_by_file:
                        warning_by_file[file_part] = []
                    warning_by_file[file_part].append(message)
                else:
                    if "General" not in warning_by_file:
                        warning_by_file["General"] = []
                    warning_by_file["General"].append(warning)

            for file_name, file_warnings in warning_by_file.items():
                report.append(f"  📁 {file_name}:")
                for warning in file_warnings:
                    report.append(f"    - {warning}")
                report.append("")

        if not self.errors and not self.warnings:
            report.append("✅ All validations passed!")

        report_content = "\n".join(report)

        # Write report to file
        Path("validation-report.txt").write_text(report_content, encoding="utf-8")

        print(f"\n{report_content}")

        return len(self.errors) == 0


def main() -> None:
    """Run the main validation process."""
    print("Starting iCalendar validation...")

    validator = ICalValidator()
    validator.validate_all_files()
    overall_success = validator.generate_report()

    if overall_success:
        print("\n✅ Validation completed successfully!")
        sys.exit(0)
    else:
        print(
            f"\n❌ Validation failed with {len(validator.errors)} errors",
        )
        sys.exit(1)


if __name__ == "__main__":
    main()
