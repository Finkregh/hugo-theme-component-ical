#!/usr/bin/env python3
"""iCalendar Validation Script for Hugo iCalendar Templates.

This script validates the generated .ics files to ensure they:
1. Are valid iCalendar format
2. Contain expected properties
3. Have correct recurrence rules
4. Match the source markdown content
"""

# ruff: noqa: T201, ANN401, E501

import sys
from pathlib import Path
from typing import Any

import structlog
import yaml
from dateutil.rrule import rrulestr
from icalendar import Calendar, Component

# Configure structlog
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(),
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

log = structlog.get_logger()

# Constants
MIN_PATH_PARTS = 2
CALENDAR_FILENAME = "calendar.ics"


class ICalValidator:
    """Validator for iCalendar files generated by Hugo templates."""

    def __init__(self) -> None:
        """Initialize the validator with empty error and warning lists."""
        self.errors: list[str] = []
        self.warnings: list[str] = []
        self.validated_files: int = 0

    def log_error(self, message: str, **kwargs: Any) -> None:
        """Log an error message."""
        self.errors.append(message)
        log.error(message, **kwargs)

    def log_warning(self, message: str, **kwargs: Any) -> None:
        """Log a warning message."""
        self.warnings.append(message)
        log.warning(message, **kwargs)

    def log_info(self, message: str, **kwargs: Any) -> None:
        """Log an info message."""
        log.info(message, **kwargs)

    def parse_markdown_frontmatter(self, md_file: str) -> dict[str, Any]:
        """Parse the YAML frontmatter from a markdown file."""
        try:
            content = Path(md_file).read_text(encoding="utf-8")

            # Extract frontmatter between --- markers
            if content.startswith("---\n"):
                end_marker = content.find("\n---\n", 4)
                if end_marker != -1:
                    frontmatter = content[4:end_marker]
                    return yaml.safe_load(frontmatter) or {}
            else:
                return {}
        except (OSError, yaml.YAMLError) as e:
            self.log_error(
                "Failed to parse frontmatter from file",
                md_file=md_file,
                error=str(e),
            )
        return {}

    def validate_ical_structure(self, cal: Calendar, ics_file: str) -> Component | None:
        """Validate basic iCalendar structure."""
        self.log_info("Validating structure", ics_file=ics_file)

        # Check for required calendar properties
        if not cal.get("VERSION"):
            self.log_error("Missing VERSION property", ics_file=ics_file)

        if not cal.get("PRODID"):
            self.log_error("Missing PRODID property", ics_file=ics_file)

        # Check for events
        events = [component for component in cal.walk() if component.name == "VEVENT"]
        if not events:
            self.log_error("No VEVENT components found", ics_file=ics_file)
            return None

        return events[0]  # Return first event for further validation

    def validate_event_properties(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate event properties against frontmatter."""
        self.log_info("Validating event properties", ics_file=ics_file)

        # Check SUMMARY (title)
        if "title" in frontmatter:
            summary = event.get("SUMMARY")
            if summary:
                if str(summary) != frontmatter["title"]:
                    self.log_error(
                        "SUMMARY doesn't match title",
                        ics_file=ics_file,
                        summary=str(summary),
                        expected_title=frontmatter["title"],
                    )
            else:
                self.log_error("Missing SUMMARY property", ics_file=ics_file)

        # Check DTSTART
        if "startDate" in frontmatter:
            dtstart = event.get("DTSTART")
            if not dtstart:
                self.log_error("Missing DTSTART property", ics_file=ics_file)

        # Check DTEND
        if "endDate" in frontmatter:
            dtend = event.get("DTEND")
            if not dtend:
                self.log_error("Missing DTEND property", ics_file=ics_file)

        # Check UID
        uid = event.get("UID")
        if not uid:
            self.log_error("Missing UID property", ics_file=ics_file)

        # Check DTSTAMP
        dtstamp = event.get("DTSTAMP")
        if not dtstamp:
            self.log_error("Missing DTSTAMP property", ics_file=ics_file)

    def _validate_freq(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate FREQ parameter."""
        if "freq" in expected_rule:
            actual_freq = rrule.get("FREQ")
            expected_freq = [expected_rule["freq"]]
            if actual_freq != expected_freq:
                self.log_error(
                    "FREQ mismatch",
                    ics_file=ics_file,
                    expected=expected_rule["freq"],
                    actual=actual_freq,
                )

    def _validate_bymonth(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYMONTH parameter."""
        if "byMonth" in expected_rule:
            expected_month = [expected_rule["byMonth"]]
            actual_month = rrule.get("BYMONTH")
            if actual_month != expected_month:
                self.log_error(
                    "BYMONTH mismatch",
                    ics_file=ics_file,
                    expected=expected_month,
                    actual=actual_month,
                )

    def _validate_byday(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYDAY parameter."""
        if "byDay" in expected_rule:
            expected_day = expected_rule["byDay"]
            # Normalize to list for comparison
            if not isinstance(expected_day, list):
                expected_day = [expected_day]

            actual_day = rrule.get("BYDAY")
            if actual_day != expected_day:
                self.log_error(
                    "BYDAY mismatch",
                    ics_file=ics_file,
                    expected=expected_day,
                    actual=actual_day,
                )

    def _validate_bysetpos(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate BYSETPOS parameter."""
        if "bySetPos" in expected_rule:
            expected_setpos = expected_rule["bySetPos"]
            if isinstance(expected_setpos, list):
                expected_setpos_list = expected_setpos
            else:
                expected_setpos_list = [expected_setpos]
            actual_setpos = rrule.get("BYSETPOS")
            if actual_setpos != expected_setpos_list:
                self.log_error(
                    "BYSETPOS mismatch",
                    ics_file=ics_file,
                    expected=expected_setpos_list,
                    actual=actual_setpos,
                )

    def _validate_interval(
        self,
        rrule: Component,
        expected_rule: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate INTERVAL parameter."""
        if "interval" in expected_rule:
            expected_interval = [expected_rule["interval"]]
            actual_interval = rrule.get("INTERVAL")
            if actual_interval != expected_interval:
                self.log_error(
                    "INTERVAL mismatch",
                    ics_file=ics_file,
                    expected=expected_interval,
                    actual=actual_interval,
                )

    def show_recurrence_entries(self, event: Component, ics_file: str) -> None:
        """Show the first 4 entries from recurrence rules."""
        rrule = event.get("RRULE")
        if not rrule:
            return

        dtstart = event.get("DTSTART")
        if not dtstart:
            return

        try:
            # Convert rrule to string format for dateutil
            rrule_str = str(rrule).replace("RRULE:", "")
            start_dt = dtstart.dt

            # Handle timezone-aware datetime
            if hasattr(start_dt, "replace") and start_dt.tzinfo is None:
                start_dt = start_dt.replace(tzinfo=None)

            # Generate first 4 occurrences
            rule = rrulestr(rrule_str, dtstart=start_dt)
            occurrences = list(rule[:4])

            print(f"\n📅 First 4 recurrence entries for {ics_file}:")
            for i, occurrence in enumerate(occurrences, 1):
                print(f"  {i}. {occurrence.strftime('%Y-%m-%d %H:%M:%S')}")

        except Exception as e:  # noqa: BLE001
            self.log_warning(
                f"Could not generate recurrence entries: {e}",
                ics_file=ics_file,
            )

    def validate_recurrence_rule(
        self,
        event: Component,
        frontmatter: dict[str, Any],
        ics_file: str,
    ) -> None:
        """Validate recurrence rule against frontmatter."""
        if "recurrenceRule" not in frontmatter:
            return  # No recurrence rule expected

        self.log_info("Validating recurrence rule", ics_file=ics_file)

        rrule = event.get("RRULE")
        if not rrule:
            self.log_error("Expected RRULE but none found", ics_file=ics_file)
            return

        # Show first 4 recurrence entries
        self.show_recurrence_entries(event, ics_file)

        expected_rule = frontmatter["recurrenceRule"]

        # Validate individual components
        self._validate_freq(rrule, expected_rule, ics_file)
        self._validate_bymonth(rrule, expected_rule, ics_file)
        self._validate_byday(rrule, expected_rule, ics_file)
        self._validate_bysetpos(rrule, expected_rule, ics_file)
        self._validate_interval(rrule, expected_rule, ics_file)

    def validate_ics_file(self, ics_file: str, md_file: str | None = None) -> bool:
        """Validate a single .ics file."""
        self.log_info("Validating file", ics_file=ics_file)

        try:
            ics_data = Path(ics_file).read_text(encoding="utf-8")
            cal = Calendar.from_ical(ics_data)
        except (OSError, ValueError) as e:
            self.log_error("Failed to parse file", ics_file=ics_file, error=str(e))
            return False

        # Validate basic structure
        event = self.validate_ical_structure(cal, ics_file)
        if event is None:
            return False

        # If we have a corresponding markdown file, validate against it
        if md_file and Path(md_file).exists():
            frontmatter = self.parse_markdown_frontmatter(md_file)
            if frontmatter:
                self.validate_event_properties(event, frontmatter, ics_file)
                self.validate_recurrence_rule(event, frontmatter, ics_file)

        self.validated_files += 1
        return True

    def find_corresponding_markdown(self, ics_file: str) -> str | None:
        """Find the corresponding markdown file for an .ics file."""
        # Extract event name from path
        # e.g., demo/public/events/event_3_yearly_april/calendar.ics
        # -> event_3_yearly_april
        path_parts = Path(ics_file).parts
        if len(path_parts) >= MIN_PATH_PARTS and path_parts[-1] == CALENDAR_FILENAME:
            event_name = path_parts[-2]
            md_file = f"demo/content/events/{event_name}.md"
            if Path(md_file).exists():
                return md_file
        return None

    def verify_recurrence_rule_consistency(self) -> bool:
        """Verify that markdown files with recurrenceRule have RRULE in their .ics files."""
        print("\n🔍 Verifying recurrence rule consistency...")

        # Find all markdown files with recurrenceRule
        md_files = list(Path("demo/content/events").glob("*.md"))
        md_files = [f for f in md_files if f.name != "_index.md"]

        success = True
        files_with_recurrence = 0

        for md_file in sorted(md_files):
            frontmatter = self.parse_markdown_frontmatter(str(md_file))
            if "recurrenceRule" in frontmatter:
                files_with_recurrence += 1
                event_name = md_file.stem
                ics_file = f"demo/public/events/{event_name}/calendar.ics"

                print(f"📋 Checking {event_name}:")
                print(f"   Markdown: {md_file}")
                print(f"   ICS file: {ics_file}")

                if not Path(ics_file).exists():
                    self.log_error(
                        f"ICS file not found for {event_name}",
                        md_file=str(md_file),
                    )
                    success = False
                    continue

                try:
                    ics_data = Path(ics_file).read_text(encoding="utf-8")
                    cal = Calendar.from_ical(ics_data)

                    # Find VEVENT component
                    events = [
                        component
                        for component in cal.walk()
                        if component.name == "VEVENT"
                    ]
                    if not events:
                        self.log_error(
                            f"No VEVENT found in {ics_file}",
                            md_file=str(md_file),
                        )
                        success = False
                        continue

                    event = events[0]
                    rrule = event.get("RRULE")

                    if rrule:
                        print(f"   ✅ RRULE found: {rrule}")
                    else:
                        self.log_error(
                            f"RRULE missing in {ics_file} but recurrenceRule present in {md_file}",
                        )
                        success = False

                except Exception as e:  # noqa: BLE001
                    self.log_error(
                        f"Error processing {ics_file}: {e}",
                        md_file=str(md_file),
                    )
                    success = False

        print(f"\n📊 Found {files_with_recurrence} markdown files with recurrenceRule")
        return success

    def validate_all_files(self) -> bool:
        """Validate all .ics files in the demo/public/events directory."""
        ics_files = list(Path("demo/public/events").rglob("*.ics"))

        if not ics_files:
            self.log_error("No .ics files found in demo/public/events/")
            return False

        self.log_info("Found files to validate", count=len(ics_files))

        success = True
        for ics_file in sorted(ics_files):
            md_file = self.find_corresponding_markdown(str(ics_file))
            if not self.validate_ics_file(str(ics_file), md_file):
                success = False

        # Also verify recurrence rule consistency
        if not self.verify_recurrence_rule_consistency():
            success = False

        return success

    def generate_report(self) -> bool:
        """Generate a validation report."""
        report = []
        report.append("iCalendar Validation Report")
        report.append("=" * 30)
        report.append(f"Files validated: {self.validated_files}")
        report.append(f"Errors: {len(self.errors)}")
        report.append(f"Warnings: {len(self.warnings)}")
        report.append("")

        if self.errors:
            report.append("ERRORS:")
            report.extend(f"  - {error}" for error in self.errors)
            report.append("")

        if self.warnings:
            report.append("WARNINGS:")
            report.extend(f"  - {warning}" for warning in self.warnings)
            report.append("")

        if not self.errors and not self.warnings:
            report.append("✅ All validations passed!")

        report_content = "\n".join(report)

        # Write report to file
        Path("validation-report.txt").write_text(report_content, encoding="utf-8")

        print(f"\n{report_content}")

        return len(self.errors) == 0


def main() -> None:
    """Run the main validation process."""
    print("Starting iCalendar validation...")

    validator = ICalValidator()
    validator.validate_all_files()
    overall_success = validator.generate_report()

    if overall_success:
        print("\n✅ Validation completed successfully!")
        sys.exit(0)
    else:
        print(
            f"\n❌ Validation failed with {len(validator.errors)} errors",
        )
        sys.exit(1)


if __name__ == "__main__":
    main()
